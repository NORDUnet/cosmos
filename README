Cosmos - A simple Configuration Management System

   cosmos (countable and uncountable; plural cosmoi or cosmoses)

     The universe
     An ordered, harmonious system or whole
     Order or harmony

   κόσμος (genitive κόσμου) m, second declension; (kosmos)

     order
     lawful order, government
     mode, fashion
     ornament, decoration
     honour, credit
     ruler
     world, universe, the earth
     mankind

Introduction
------------

Cosmos install/delete files on systems and execute custom-written
scripts to perform sysadmin tasks.  Cosmos is intended to be used with
a version controlled repository that hold the Cosmos "model" file
hierarchy for a particular machine.  Usually the repository is
centralized and Cosmos helps with fetching and verify integrity of the
repository.

Cosmos configuration file lives in /etc/cosmos/cosmos.conf by default.
You may use the COSMOS_CONF_DIR to specify a separate configuration
directory, which should contain cosmos.conf and the various *.d
sub-directories.

The default place for the Cosmos "model" hierarchy is
/var/cache/cosmos/model.  It is specified in cosmos.conf by setting
the COSMOS_MODEL environment variable.  You may also override it using
the --root (or -r for short) on the command line.

To understand what Cosmos helps you with, consider a system tree
structure like this:

   /etc/cosmos/cosmos.conf
   /var/cache/cosmos/model/overlay/root/.ssh/foobar
   /var/cache/cosmos/model/delete/etc/somewhere/file-to-be-removed

The cosmos.conf file contains this:

COSMOS_MODEL=/var/cache/cosmos/model
COSMOS_ROOT=/

The content of the two other files are irrelevant here.

The /var/cache/cosmos/model/overlay/root/.ssh/foobar file holds a SSHD
file to be installed as /root/.ssh/foobar.  (In this example I'm not
using '.authorized_keys' as an example to avoid accidental overwrites
when you test configurations.)

The /var/cache/cosmos/model/delete/etc/somewhere/file-to-be-removed is
a placeholder file to indicate that the file
/etc/somewhere/file-to-be-removed should be removed.  Below we'll
assume that you have a real file /etc/somewhere/file-to-be-removed on
your system that should be removed.

You can dry-run cosmos by using --dry-run (or -n for short).  In this
setup it would print the following.  It doesn't do anything!  No files
are removed and nothing is rsync'ed.

root@latte:~# cosmos -n apply
rm -f "/"/"./etc/somewhere/file-to-be-removed"
rsync --archive /var/cache/cosmos/model/overlay/ /
root@latte:~# 

This dry mode is not as useful as it could be, because you only see
that rsync will be invoked but not what it would do.  To run cosmos in
a semi-dry mode, which will invoke rsync in dry mode, there is the
--dry-tasks (or -N for short).

root@latte:~# cosmos -N apply
rm -f "/"/"./etc/somewhere/file-to-be-removed"
sending incremental file list
root/.ssh/
root/.ssh/foobar

sent 89 bytes  received 20 bytes  218.00 bytes/sec
total size is 4  speedup is 0.04 (DRY RUN)
root@latte:~# 

If you think the output from the dry runs looks harmless, you can run
it for real.  Here the --verbose (or -v fort short) mode is enabled,
otherwise the command is silent.

root@latte:~# cosmos -v apply
40delete: Removing './etc/somewhere/file-to-be-removed'
60overlay: Invoking rsync --archive -v /var/cache/cosmos/model/overlay/ /
sending incremental file list
root/.ssh/
root/.ssh/foobar

sent 133 bytes  received 36 bytes  338.00 bytes/sec
total size is 4  speedup is 0.02
root@latte:~# 

This illustrate the fundamental task that cosmos does.

Task scripts
------------

All executable files in the pre-tasks.d and post-tasks.d sub-directory
in the Cosmos model are invoked in order, sorted by 'sort'.  Each
script should print to stdout the shell commands it wants to perform.
To write proper task scripts you should follow the following rules.

* No side effects!

  Your script should not modify the state of the system.  Only print
  to stdout the commands you want performed.

* Run fast!

  The script may be invoked many times, sometimes frequently, and
  should finish quickly.  A simple way to achieve this is to wrap most
  of the commands on the script in a 'if...fi' clause that checks for
  the existance of some stamp file.  Either like this:

  if test -f /var/spool/cosmos/foobar.stamp; then

     echo 'apt-get install foobar'
     ...
     echo 'mkdir -p /var/spool/cosmos'
     echo 'touch /var/spool/cosmos/foobar.stamp'
  fi

  Or without the need for a stamp file like this:

  if test -f /usr/bin/foobar; then
     echo 'apt-get install foobar'
  fi

* Master the art of shell quoting!

  To handle strings with embedded space, control characters or even
  newlines safely, you need to be on top of your shell quoting.  It is
  convenient to use "here documents" to output multiple lines, like this:

  cat<<EOF
	git config --global user.name "Root on `hostname`"
	cp $HOME/foo /etc/bar
  EOF

  The effects of that may not be what you expect it to be, since the `
  and $ are evaluated when the cat command is run.  This could lead to
  violating rule #1 of no side effects if your `` command happens to
  cause side effects.

  If the limit string (EOF in our example) is quoted, evaluation of `
  and $ etc won't happen.  Further, if the limit string is prefixed
  with '-' it will suppress leading tabs (but not spaces) in the
  output.  This can be used to make your scripts more readable.

  cat<<-'EOF'
	git config --global user.name "Root on `hostname`"
	cp $HOME/foo /etc/bar
  EOF

  Of course, sometimes you may WANT evaluation of ` or $ to happen.
  The code here may be an example of that, sometimes you want the
  hostname and $HOME content to be clear when using Cosmos in dry
  mode.

* No interactive prompts

  The scripts may run unattended so they should not rely on having a
  user present.

  Exceptions may include some initial bootstrapping code if you make
  sure to always run those interactively and make sure that they are
  never invoked again.
